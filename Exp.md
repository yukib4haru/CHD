6.8  
往vector<基类> push_back了一个派生类对象，现在如何从这个vector中取出这个派生类对象？并且可以使用派生类中的接口函数？    
解决方案   
1.对象切割（Object slicing）   
一般来说，衍生类所占的存储空间一般都比基础类大。当用基础类强制转换派生类物件（对象）指標时就会产生对象切割（Object slicing），即： 当把一个派生类对象赋给一个基类对象时或者 用基类对象强制转换派生类对象就会发生对象切割。    
2.解决方案： 多态的实现是通过指针和引用    


6.7
我有一个小问题，那就是我们为什么不直接创建一个私有变量Button而往往使用一个指针，然后在成员函数中在初始化它呢  
this->skillAbtn = new Button(this);  
——  
使用指针初始化成员变量skillAbtn,而不是直接创建Button对象,有以下几个原因:  
1. 动态内存分配。使用new关键字可以在堆上动态分配Button对象,而不是在栈上创建。当对象较大时,这可以更加合理地利用内存。  
2. 指针可以为空(NULL)。skillAbtn作为指针,可以初始化为NULL,表示当前尚未创建按钮。当真正需要按钮时,再进行动态创建。这可以避免创建不需要的对象。   
3. 指针可以更改指向。skillAbtn作为指针,可以重新指向其他按钮对象。这为按钮的替换或删除提供了灵活性。如果直接使用Button对象,这将更加困难。   
4. 指针可以简化内存管理。我们可以在不需要按钮时,直接调用delete释放skillAbtn指向的内存。如果使用对象,需要提供析构函数进行内存清理,这会更加麻烦。   
所以,总体来说,使用指针成员变量而不是直接创建对象,可以提供更高的灵活性。它可以动态的分配与释放内存,更改指向,避免不必要的对象创建,从而简化内存管理。这在GUI开发以及大对象的处理中尤为重要。  
但是,指针也需要我们谨慎地进行内存管理,避免内存泄露等问题的产生。这需要我们对指针和内存机制有扎实的理解,在项目开发中不断学习和运用。   